/*-------------------------------------------------------------------------
 @@COPYRIGHT@@
 *-----------------------------------------------------------------------*/

#ifndef __CML_MATHLIB_RANDOM_UNIT_TPP
#  error "mathlib/random_unit.tpp not included correctly"
#endif

#include <cml/scalar/functions.h>
#include <cml/vector/detail/check_or_resize.h>
#include <cml/vector/writable_vector.h>
#include <cml/vector/dot.h>

namespace cml {
namespace detail {
/** Generate a random 2D unit vector in a cone with direction @c d and
 * half-angle @c a, given in radians.
 */
template<class Sub1, class Sub2, class Scalar>
void
random_unit(writable_vector<Sub1>& n, const readable_vector<Sub2>& d,
  const Scalar& a, cml::int_c<2>)
{
  using theta_traits = scalar_traits<Scalar>;

  /* Generate a uniformly random angle in [-a,a]: */
  auto theta = cml::random_real(-a, a);

  /* sin(theta) and cos(theta): */
  auto st = theta_traits::sin(theta);
  auto ct = theta_traits::cos(theta);

  /* Compute n by rotating d by theta: */
  n[0] = ct * d[0] - st * d[1];
  n[1] = st * d[0] + ct * d[1];

  /* Normalize: */
  n.normalize();
}

/** Generate a random n-D unit vector in a cone with direction @c d and
 * half-angle @c a, given in radians.  The vector is generated by using two
 * slerps to linearly map a random vector on the unit hemisphere to the
 * spherical cone cap.  This seems to produce nice (uniform) 3D
 * distributions, at least visually.
 */
template<class Sub1, class Sub2, class Scalar, int N>
void
random_unit(writable_vector<Sub1>& n, const readable_vector<Sub2>& d,
  const Scalar& a, cml::int_c<N>)
{
  using a_traits = scalar_traits<Scalar>;

  /* Generate a uniformly random vector on the unit sphere: */
  cml::random_unit(n);

  /* Reorient n to be within 90 degrees of d: */
  auto cos_O = dot(n, d); // [-1,1]
  if(cos_O < 0) {
    n = -n;
    cos_O = -cos_O;
  }

  /* Compute the angle between d and n: */
  auto O = acos_safe(cos_O);
  using O_type = decltype(O);
  using O_traits = scalar_traits<O_type>;
  using Oa_traits = scalar_traits<decltype(O - a)>;

  /* Use slerp between d (t=0) and n (t=1) to find the unit vector n_a
   * (t=a/O) lying on the cone between d and n:
   */
  auto n_a =
    (Oa_traits::sin(O - a) * d + a_traits::sin(a) * n) / O_traits::sin(O);
  /* Note: n_a is normalized by dividing by sin(O). */

  /* Use a second slerp to "scale" the cone with half-angle O to the cone
   * with half-angle a, taking the random vector n along with it:
   */
  auto t = O / constants<O_type>::pi_over_2();
  n = (Oa_traits::sin((O_type(1) - t) * a) * d + Oa_traits::sin(t * a) * n_a)
    / a_traits::sin(a);
  /* Note: n is normalized by dividing by sin(a). */
}
} // namespace detail

template<class Sub, class RNG>
void
random_unit(writable_vector<Sub>& n, RNG& gen)
{
  using value_type = value_type_trait_of_t<Sub>;
  static_assert(std::is_floating_point_v<value_type>,
    "floating-point coordinates required");
  cml::check_minimum_size(n, cml::int_c<1>());

  /* Generate coordinates using a normal distribution having mean of 0 and
   * standard deviation of 1:
   */
  std::normal_distribution<value_type> d(value_type(0), value_type(1));

  /* Generate coordinates, avoiding the (improbable) case of 0 length: */
  value_type length(0);
  do {
    for(int i = 0; i < n.size(); ++i) n[i] = d(gen);
    length = n.length_squared();
  } while(length == value_type(0));

  /* Normalize the vector: */
  n.normalize();
}

template<class Sub>
void
random_unit(writable_vector<Sub>& n)
{
  static std::random_device rd;
  static std::default_random_engine gen(rd());
  random_unit(n, gen);
}

template<class Sub1, class Sub2, class Scalar>
void
random_unit(writable_vector<Sub1>& n, const readable_vector<Sub2>& d,
  const Scalar& a)
{
  using value_type = value_type_trait_of_t<Sub1>;
  static_assert(std::is_floating_point_v<value_type>,
    "floating-point coordinates required");
  cml_require(a > 0 && a <= constants<value_type>::pi_over_2(),
    std::invalid_argument, "a must be in (0,90] deg");

  cml::detail::check_or_resize(n, d);
  detail::random_unit(n, d, a, cml::int_c<array_size_of_c<Sub2>::value>());
}
} // namespace cml
